package main

/*
Реализовать структуру-счетчик,
 которая будет инкрементироваться в конкурентной среде.
 По завершению программа должна выводить итоговое значение счетчика.

*/

import (
	"fmt"
	"sync"
)

// Сама структура
type Counter struct {
	counter int
}

// Функция, которая будет считать
func Count(channel chan struct{}, number *Counter, wg *sync.WaitGroup) {
	for range channel { //Получая данные из канала
		number.counter++ //Мы считаем
	}
	wg.Done()

}

func main() {
	c := Counter{counter: 0} //Инициализируем структуру
	n := 200                 //Будем считать до n

	channel := make(chan struct{}, n) //Создаём канал, который будет служить сигналом для счётчика
	//Буферизируем канал, чтобы он не замедлял работу горутин
	chanWg := sync.WaitGroup{} //Эта группа для функции подсчёта
	wg := sync.WaitGroup{}

	chanWg.Add(1) //Эта группа отвечает за одну горутину
	go Count(channel, &c, &chanWg)

	wg.Add(n) //Столько будет горутин, которые будут сигнализировать первональной горутине о счёте
	for i := 0; i < n; i++ {
		go func(i int) {
			channel <- struct{}{} //Отправляем в канал пустую структуру, так как она занимает мало места
			// и тем самым сигнализируем о росте счётчика
			wg.Done()
		}(i)
	}

	wg.Wait()      //Ожидаем завершения горутине, которые сигнализируют
	close(channel) //Закрываем канал, тем самым завершая первоначальную горутину
	chanWg.Wait()  //Ждём завершения первоначальной горутины

	fmt.Println(c.counter) //Выводит значение n, если всё верно

}
